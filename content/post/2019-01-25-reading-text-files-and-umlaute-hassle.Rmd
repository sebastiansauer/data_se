---
title: Reading text files and Umlaute hassle
author: Sebastian Sauer
date: '2019-01-25'
slug: reading-text-files-and-umlaute-hassle
categories:
  - rstats
tags:
  - text
  - Encoding
editor_options: 
  chunk_output_type: console
---


Data is often stored as plain text file. That's good because it is a simple format. However, simplicity comes with a cost: Not all questions may have definite answers. The most common hassle when reading/importing text files is that the encoding scheme is unknown, aka wrong. This problem mostly occurs when, say, a Mac user stores a text file, where per default UTF8 text encoding is applied. In contrast, on a Windows machine, Windows-encoding (often dubbed "latin1","Windows 1252"  or "ISO-8859-1") is the default. What happens then is similar to what would happen if type a letter any you read thinking that it is in French -- confusion guaranted.

With a little more details,

- ["Windows 1252"](https://en.wikipedia.org/wiki/Windows-1252) is a widely used 8-bit encoding scheme, including mostly English letters.
- ["ISO-8859-1"](https://en.wikipedia.org/wiki/ISO/IEC_8859-1) is also 8-bit, and covers the latin character set, thereby suitably depicting most European Languages. For example, the letter "A" is encoded as "0032" (hex).
- ["UTF-8"](https://en.wikipedia.org/wiki/UTF-8) ("Unicode Transformation Format") is the predominant encoding in the WWW; it covers more than 100 scripts (languages) from all over the world, including emojis, and special characters. Encoding a letter via UTF8 may produce a byte sequence betweeen 1 and 4 bytes. More frequently used letters are stored in the beginning of the code page, so that only 1 byte is needed for encoding.

According to [Wikipedia](), UTF8 is the defacto standard in the internet:

![](https://en.wikipedia.org/wiki/File:Utf8webgrowth.svg)

A little more in depth, consider that the text binary representation for some text (string). It will be pinned down to some bits and bytes. The question is what "translation code" from text to bits (or vice versa) is used? That's exactly what's defined in a text encoding scheme such aus UTF8. By the way, it seems that UTF8 is a reasonable standard, dear Windows user, consider following this standard. Your favorite text editor, such as Notepad++, or Text Mate, will offer you an option to "save with encoding" or similar. By the way, RStudio will do that for you, too (see File > Save with Encoding...).


So much for theory. Now, let's test it. Assume we have a text file, and we do not know the encoding. So what we do is, we *guess* it:


```{r}
library(readr)
```

Here's the file (ignore for the moment that the file name suggests an encoding):

```{r}
fileurl <- "https://data-se.netlify.com/download/text-latin1.csv"
```


```{r eval = FALSE}
guess_encoding(fileurl)
```


Now that we have an educated guess, let's try to parse it:


```{r eval = FALSE}
text <- read_csv(file = url, locale = locale(encoding = "ISO-8859-1"))
```


Let's see whether it worked out:

```{r eval = FALSE}
text
```


Worked. Of course we can define the encoding when writing to a text file too:

```{r}

```

