<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tidyverse on Data Se</title>
    <link>/tags/tidyverse/</link>
    <description>Recent content in Tidyverse on Data Se</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/tidyverse/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ornaments with ggformula</title>
      <link>/2019/02/12/ornaments-with-gformula/</link>
      <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/02/12/ornaments-with-gformula/</guid>
      <description>Since some time, there‚Äôs a wrapper for ggplot2 available, bundled in the package ggformula. One nice thing is that in that it plays nicely with the popular R package mosaic. mosaic provides some useful functions for modeling along with a tamed and consistent syntax. In this post, we will discuss some ‚Äúornaments‚Äù, that is, some details of beautification of a plot. I confess that every one will deem it central, but in some cases in comes in handy to know how to ‚Äúrefine‚Äù a plot using ggformula.</description>
    </item>
    
    <item>
      <title>An illustration of tidyverse‚Äô gather/spread</title>
      <link>/2019/01/15/an-illustration-of-tidyverse-gather-spread/</link>
      <pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/01/15/an-illustration-of-tidyverse-gather-spread/</guid>
      <description>Frequently, datasets have to be reshaped before further analysis. One particular important step is to transform a data frame from ‚Äúwide‚Äù to ‚Äúlong‚Äù format. This is illustrated by the following diagram, taken from by new book on data analysis (Image licence: CC-BY-NC).</description>
    </item>
    
    <item>
      <title>Changing the default color scheme in ggplot2</title>
      <link>/2018/12/12/changing-the-default-color-scheme-in-ggplot2/</link>
      <pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/12/12/changing-the-default-color-scheme-in-ggplot2/</guid>
      <description>UPDATE: see update below based on comments from nmarkgraf.
UPDATE 2: I changed the theme to theme_minimal thanks to the comment from @neuwirthe.
UPDATE 3: A more efficient way to plot a discrete scale using viridis. Thanks to flying sheep; see way 4 below
The default color scheme in ggplot2 is suitable for many purposes, but, for instance, it is not suitable for b/w printing, and maybe not suitable for persons with limited color perception.</description>
    </item>
    
    <item>
      <title>Applying a function to each row of a data frame</title>
      <link>/2018/12/07/applying-a-function-to-each-row-of-a-data-frame/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/12/07/applying-a-function-to-each-row-of-a-data-frame/</guid>
      <description>A typical and quite straight forward operation in R and the tidyverse is to apply a function on each column of a data frame (or on each element of a list, which is the same for that regard).
However, the orthogonal question of ‚Äúhow to apply a function on each row‚Äù is much less labored. We will look at this question in this post, and explore some (of many) answers to this question.</description>
    </item>
    
    <item>
      <title>Plot many ggplot diagrams using nest() and map()</title>
      <link>/2018/12/05/plot-many-ggplot-diagrams-using-nest-and-map/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/12/05/plot-many-ggplot-diagrams-using-nest-and-map/</guid>
      <description>At times, it is helpful to plot a multiple of related diagrams, such as a scatter plot for each subgroup. As always, there a number of ways of doing so in R. Specifically, we will make use of ggplot2.
library(tidyverse) library(glue) data(mtcars) d &amp;lt;- mtcars %&amp;gt;% rownames_to_column(var = &amp;quot;car_names&amp;quot;) Is d a tibble`
is_tibble(d) #&amp;gt; [1] FALSE What is it?
class(d) #&amp;gt; [1] &amp;quot;data.frame&amp;quot; Okay, let‚Äôs make a tibble out of it:</description>
    </item>
    
    <item>
      <title>What are the names of the cars with 4 cylinders?</title>
      <link>/2018/12/03/what-are-the-names-of-the-cars-with-4-cylinders/</link>
      <pubDate>Mon, 03 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>/2018/12/03/what-are-the-names-of-the-cars-with-4-cylinders/</guid>
      <description>Recently, some one asked me in a workshop this question: ‚ÄúWhat are the names of the cars with 4 (6,8) cylinders?‚Äù (he referred to the mtcars data set). That was a workshop on the tidyverse, so the question is how to answer this question using tidyverse techniques.
First, let‚Äôs load the usual culprits.
library(tidyverse) library(purrrlyr) library(knitr) library(stringr) data(mtcars) d &amp;lt;- as_tibble(mtcars) %&amp;gt;% rownames_to_column(var = &amp;quot;car_names&amp;quot;) d %&amp;gt;% head() %&amp;gt;% kable()   car_names mpg cyl disp hp drat wt qsec vs am gear carb    Mazda RX4 21.</description>
    </item>
    
    <item>
      <title>Interactive diagrams in lieu of shiny?</title>
      <link>/2017/11/27/interactive-diagrams-in-lieu-of-shiny/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/11/27/interactive-diagrams-in-lieu-of-shiny/</guid>
      <description>One frequent use of the Shiny server software is displaying interactive data diagrams. The pro of using Shiny is the great flexibility; much more than ‚Äújust graphics‚Äù can be done. Basically Shiny provides a flexible GUI for your R program. But if you simply aiming at displaying or exploring some data interactively, a much simplor approach may do it for you; there are some nice libraries available in R for that.</description>
    </item>
    
    <item>
      <title>Use case for purrr::map</title>
      <link>/2017/11/23/use-case-for-purrr-map/</link>
      <pubDate>Thu, 23 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/11/23/use-case-for-purrr-map/</guid>
      <description> library(tidyverse) ## ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.2.1 ‚îÄ‚îÄ ## ‚úî ggplot2 3.1.0 ‚úî purrr 0.2.5 ## ‚úî tibble 1.4.2 ‚úî dplyr 0.7.8 ## ‚úî tidyr 0.8.2 ‚úî stringr 1.3.1 ## ‚úî readr 1.1.1 ‚úî forcats 0.3.0 ## ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ ## ‚úñ dplyr::filter() masks stats::filter() ## ‚úñ dplyr::lag() masks stats::lag() d &amp;lt;- data_frame( id = c(1,1,1,1,1,1,2,2,3,3,3,4,1,2,2) ) d$id %&amp;gt;% map </description>
    </item>
    
    <item>
      <title>Pass multiple functions and arguments to purrr::map</title>
      <link>/2017/11/21/pass-multiple-functions-and-arguments-to-purrr-map/</link>
      <pubDate>Tue, 21 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/11/21/pass-multiple-functions-and-arguments-to-purrr-map/</guid>
      <description>I just run in the following problem: I wanted to map multiple functions to multiple columns, and I needed to pass some arguments to this map call. Sound theoretical, I know. Consider this example:
library(tidyverse) ## ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.2.1 ‚îÄ‚îÄ ## ‚úî ggplot2 3.1.0 ‚úî purrr 0.2.5 ## ‚úî tibble 1.4.2 ‚úî dplyr 0.7.8 ## ‚úî tidyr 0.8.2 ‚úî stringr 1.3.1 ## ‚úî readr 1.1.1 ‚úî forcats 0.</description>
    </item>
    
    <item>
      <title>Replacing dplyr::do by purrr:map. Some considerations</title>
      <link>/2017/09/05/purrr-map-no-do/</link>
      <pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/09/05/purrr-map-no-do/</guid>
      <description>Hadley Wickham has announced to depreceate dplyr::do in favor of purrr:map. In a recent post, I have made use of do, so some commentators informed me about that. In this post, I will show use cases of map, specifically as a replacement of do. map is for lists; read more about lists here.
library(tidyverse) library(broom)  We will use mtcars as a sample dataframe (boring, I know, but convenient).</description>
    </item>
    
    <item>
      <title>Comparing the pipe with base methods</title>
      <link>/2017/08/31/some-pipes/</link>
      <pubDate>Thu, 31 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/08/31/some-pipes/</guid>
      <description>Some say, the pipe (#tidyverse) makes analyses in R easier. I agree. This post demonstrates some examples.
Let&amp;rsquo;s take the mtcars dataset as an example.
data(mtcars) ?mtcars  Say, we would like to compute the correlation between gasoline consumption (mpg) and horsepower (hp).
Base approach 1 cor(mtcars[, c(&amp;quot;mpg&amp;quot;, &amp;quot;hp&amp;quot;)])  ## mpg hp ## mpg 1.0000000 -0.7761684 ## hp -0.7761684 1.0000000  We use the [-operator (function) to select the columns; note that df[, c(col1, col2)] sees dataframes as matrices, and spits out a dataframe, not a vector:</description>
    </item>
    
    <item>
      <title>Programming with dplyr: Part 03, working with strings</title>
      <link>/2017/08/09/dplyr_strings/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/08/09/dplyr_strings/</guid>
      <description>More on programming with dplyr: converting quosures to strings In this post, we have programmed a simple function using dplyr&amp;rsquo;s programming capabilities based on tidyeval; for more intro to programming with dplyr, see here.
In this post, we&amp;rsquo;ll go one step further and programm a function where a quosure will be turned to a string. Why this? Because quite a number of functions out there except strings as input parameters.</description>
    </item>
    
    <item>
      <title>Programming with dplyr: Part 02, writing a function</title>
      <link>/2017/07/06/prop_fav/</link>
      <pubDate>Thu, 06 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/07/06/prop_fav/</guid>
      <description>Recently, since dplyr &amp;lt;= 0.6.0 a new way of dealing with NSE was introduced, called tidyeval. As with every topic that begs our attention, the question &amp;ldquo;why bother&amp;rdquo; is in place. Theone answer is &amp;ldquo;you&amp;rsquo;ll need this stuff if you want to lock dplyr verbs inside a function&amp;rdquo;. Once you like dplyr and friends, a natural second step is to use the ideas not only for interactive use, but for more &amp;ldquo;programming&amp;rdquo; type, ie.</description>
    </item>
    
    <item>
      <title>A second look to grouping with dplyr</title>
      <link>/2017/06/28/second_look_group_by/</link>
      <pubDate>Wed, 28 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/06/28/second_look_group_by/</guid>
      <description>The one basic idea of dplyr is that each function should focus on one job. That&amp;rsquo;s why there are no functions such as compute_sumamries_by_group_with_robust_variants(df). Rather, summarising and grouping are seen as different jobs which should be accomplished by different functions. And, in turn, that&amp;rsquo;s why group_by, the grouping function of dplyr, is of considerable importance: this function should do the grouping for each operation whatsoever.
Let&amp;rsquo;s load all tidyverse libraries in one go:</description>
    </item>
    
    <item>
      <title>Programming with dplyr: Part 01, introduction</title>
      <link>/2017/06/28/prog_dplyr_01/</link>
      <pubDate>Wed, 28 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/06/28/prog_dplyr_01/</guid>
      <description>Like for [others], Hadley Wickham&amp;rsquo;s dplyr, and more generally, the tidyverse approach has considerably changed the I do data analyses. Most notably, the pipe (coming from magrittr by Stefan Milton Bache, see here) has creeped into nearly every analyses I, do.
That is, is every analyses except for functions, and other non-interactive stuff. In those programming contexts, the dplyr way does not work, due to its non standard evaluation or NSE for short.</description>
    </item>
    
    <item>
      <title>Sorting the x-axis in bargraphs using ggplot2</title>
      <link>/2017/06/05/ordering-bars/</link>
      <pubDate>Mon, 05 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/06/05/ordering-bars/</guid>
      <description>Some time ago, I posted about how to plot frequencies using ggplot2. One point that remained untouched was how to sort the order of the bars. Let&amp;rsquo;s look at that issue here.
First, let&amp;rsquo;s load some data.
data(tips, package = &amp;quot;reshape2&amp;quot;)  And the usual culprits.
library(tidyverse) library(scales) # for percentage scales  First, let&amp;rsquo;s plot a standard plot, with bars *un*sorted.
tips %&amp;gt;% count(day) %&amp;gt;% mutate(perc = n / nrow(tips)) -&amp;gt; tips2 ggplot(tips2, aes(x = day, y = perc)) + geom_bar(stat = &amp;quot;identity&amp;quot;)  Hang on, what could &amp;lsquo;unsorted&amp;rsquo; possibly mean?</description>
    </item>
    
    <item>
      <title>Einf√ºhrung in die Datenanalyse mit R-Paket &#39;dplyr&#39; - R User Group N√ºrnberg</title>
      <link>/2017/04/27/datenanalyse_mit_dplyr/</link>
      <pubDate>Thu, 27 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/04/27/datenanalyse_mit_dplyr/</guid>
      <description>Datenjudo mit dplyr Einleitung Innerhalb der R-Landschaft hat sich das Paket dplyr binnen kurzer Zeit zu einem der verbreitesten Pakete entwickelt; es stellt ein innovatives Konzept der Datenanalyse zur Verf√ºgung. dplyr zeichnet sich durch zwei Ideen aus. Die erste Idee ist, dass nur Tabellen (&amp;ldquo;dataframes&amp;rdquo; oder &amp;ldquo;tibbles&amp;rdquo;) verarbeitet werden, keine anderen Datenstrukturen. Diese Tabellen werden von Funktion zu Funktion durchgereicht. Der Fokus auf Tabellen vereinfacht die Analyse, da Spalten nicht einzeln oder mittels Schleifen werden m√ºssen.</description>
    </item>
    
    <item>
      <title>Rowwise operations in dplyr</title>
      <link>/2017/03/27/rowwise_dplyr/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/03/27/rowwise_dplyr/</guid>
      <description>R thinks columnwise, not rowwise, at least in standard dataframe operations. A typical rowwise operation is to compute row means or row sums, for example to compute person sum scores for psychometric analyses.
One workaround, typical for R, is to use functions such as apply (and friends).
However, dplyr offers some quite nice alternative:
library(dplyr) mtcars %&amp;gt;% rowwise() %&amp;gt;% mutate(mymean=mean(c(cyl,mpg))) %&amp;gt;% select(cyl, mpg, mymean)  ## Source: local data frame [32 x 3] ## Groups: &amp;lt;by row&amp;gt; ## ## # A tibble: 32 √ó 3 ## cyl mpg mymean ## &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; ## 1 6 21.</description>
    </item>
    
    <item>
      <title>Convert list to dataframe</title>
      <link>/2017/03/08/convert_list_to_dataframe/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/03/08/convert_list_to_dataframe/</guid>
      <description>A handy function to iterate stuff is the function purrr::map. It takes a function and applies it to all elements of a given vector. This vector can be a data frame - which is a list, tecnically - or some other sort of of list (normal atomic vectors are fine, too).
However, purrr::map is designed to return lists (not dataframes). For example, if you apply mosaic::favstats to map, you will get some favorite statistics for some variable:</description>
    </item>
    
    <item>
      <title>Visualizing Interaction Effects with ggplot2</title>
      <link>/2017/01/17/vis_interaction_effects/</link>
      <pubDate>Tue, 17 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/01/17/vis_interaction_effects/</guid>
      <description>Moderator effects or interaction effect are a frequent topic of scientific endeavor. Put bluntly, such effects respond to the question whether the input variable X (predictor or independent variable IV) has an effect on the output variable (dependent variable DV) Y: &amp;ldquo;it depends&amp;rdquo;. More precisely, it depends on a second variable, M (Moderator).
More formally, a moderation effect can be summarized as follows:
 If the effect of X on Y depends on M, a moderator effect takes place.</description>
    </item>
    
    <item>
      <title>EDIT: Running multiple simple regressions with purrr</title>
      <link>/2016/09/26/edit-multiple_lm_purrr_edit/</link>
      <pubDate>Mon, 26 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/2016/09/26/edit-multiple_lm_purrr_edit/</guid>
      <description>EDIT based on comments/ suggeestions from @JonoCarroll Disqus profile and @tjmahr twitter profile. See below (last step; look for &amp;ldquo;EDIT&amp;rdquo;).
Thanks for the input! üëç
reading time: 10 min.
Hadley Wickham&amp;rsquo;s purrr has given a new look at handling data structures to the typical R user (some reasoning suggests that average users doesn&amp;rsquo;t exist, but that&amp;rsquo;s a different story).
I just tried the following with purrr: - Meditate about the running a simple regression, FWIW - Take a dataframe with candidate predictors and an outcome - Throw one predictor at a time into the regression, where the outcome variable remains the same (i.</description>
    </item>
    
    <item>
      <title>Running multiple simple regressions with purrr</title>
      <link>/2016/09/23/multiple-lm-purrr2/</link>
      <pubDate>Fri, 23 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/2016/09/23/multiple-lm-purrr2/</guid>
      <description>Hadley Wickham&amp;rsquo;s purrr has given a new look at handling data structures to the typical R user (some reasoning suggests that average users don&amp;rsquo;t exist, but that&amp;rsquo;s a different story).
I just tried the following with purrr:
 Meditate about the running a simple regression, FWIW Take a dataframe with candidate predictors and an outcome Throw one predictor at a time into the regression, where the outcome variable remains the same (i.</description>
    </item>
    
  </channel>
</rss>